#ifndef GMHJIT_DASM_INCLUDED
#define GMHJIT_DASM_INCLUDED

|.arch x64
|.actionlist gmh_acntionlist
|.section jitcode
|
|// Use rbx as our cell pointer.
|// Since rbx is a callee-save register, it will be preserved
|// across our calls to getchar and putchar.
|.define PTR, rbx
|
|.define TMP,  r15
|.define TMP2, r14
|.define TMP3, r13
|
|// Macro for calling a function.
|// In cases where our target is <=2**32 away we can use
|//   | call &addr
|// But since we don't know if it will be, we use this safe
|// sequence instead.
|.macro callp, addr
|  mov64  rax, (uintptr_t)addr
|  call   rax
|.endmacro
|
|.macro incptr, ptraddr, size
|  mov64  TMP3,  ptraddr
|  add    qword  TMP3,  size
|  mov64  ptraddr, TMP
|.endmacro

// stack heap and label tables
typedef struct {
  int* stacktop;

  int* stacklimit;

} context_t;

|.type Cxt, context_t, rcx

#define MAX_NESTING 4092


int gmhjit(dasm_State *state, Instruction *opcode, int size) {

    int step;
    // struct member's offset
    int cxtos_1 = offsetof(context_t, stacktop);
    int cxtos_2 = offsetof(context_t, stacklimit);

    //unsigned int maxpc = 0;

    // stack top ptr offset
    int s_offset = 0;
    assert(sizeof(Instruction) == 4);

    // rdi save the value of first param
    |->start:
    |  push  PTR
    |  mov   rcx,  [rdi]

    for(step = 0; step < 2/*size*/; step++, opcode++) {
        switch(*opcode) {
        // opcode t_C
        case PUSH: {
            // push next instruction to stack
            |  mov  eax,    *(opcode + 1)
            |  lea  TMP,    [rcx+cxtos_1]
            |  add  TMP,    s_offset
            |  mov  [TMP],  eax
            // stack top pointer++
            s_offset++;
            break;
        }
        default: {
            break;
        }
        }
    }

    //return SUC_RETURN;
    |  mov  rax,  Cxt
    |  pop PTR
    |  ret
    return SUC_RETURN;
}



#endif // GMHJIT_DASM_INCLUDED
